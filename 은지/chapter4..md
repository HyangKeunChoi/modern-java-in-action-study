# 스트림
- 컬렉션을 효율적으로 처리하는 방법 : 스트림

4.1 스트림이란?
- 데이터 컬렉션 반복을 처리하는 기능
- 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있음
- 익명클래스나 가비지 변수를 시용하지 않음으로서 코드를 효율적으로 구현할 수 있음
- 스트림의 장점
  - 선언형 코드 구현이 가능
  - 조립이 가능(고수준 빌딩 블록)
  - 병렬화되 데이터 처리

4.2 스트림 시작하기
- 스트림? 데이터 처리연산을 지원하도록 소스에서 추출된 연속된 요소
- 연속되 요소: 연속된 값 집합의 인터페이스 제공, 하지만 표현과 관련된 계산이 주된 요소
- 소스: 데이터 제공 소스에서 데이터 소비
- 데이터 처리 연산 : 순차적, 병렬적 실행 가능
- 파이프 라이닝: 스트림 연산끼리 연결해서 파이프 라인 형태로 구성하여 스트림 자신을 반환
- 내부 반복: 반복자 이용

4.3 스트림과 컬렉션
- 컬렉션과 스트림으 DVD오 비디오 스트리밍의 개념으로 생각
- 컬렉션은 데이터를 모두 메모리에 저장하지만 스트림은 요청할 때(필요하 때)만 데이터를 내려받는 차이
- 주의) 스트림은 한번만 소비할 수 있다
- 외부반복: 사용자가 '직접' 요소를 반복(for-each)
- 내부반복: 반복을 알아서 처리해주고 결과 값을 어딘가에 저장, 함수에 어떤 작업을 수행할지만 지정하면 됨
 ```java
 List<String> names = new ArrayList<>();
 Iterator<String> iterator = menu.iterator();
 while(iterator.hasNext()){
  Dish dish = iterator.next();
  names.add(dish.getName());
  }
  ```
  - 내부반복의 장점: 작업을 투명하게 병렬로 처리, 더 최적화된 다양한 순서로 처리가 가능
  - 스트림에서 이와 같이 내부반복을 효율적으로 처리하기 위해서는 반복을 숨겨주느 연산리스트를 미리 정의해야함(map, filter)
  
  4.4 스트림 연산
  - 중간 연산: 연결할 수 있는 스트림 연산(filter, map, limit)
    - 다른 스트림을 반환해서 질의 생성이 가능
    - 스트림 파이프라인에 실행하기 전까지는 연산 미수행(lazy)
    - 쇼트 서킷과 루프 퓨전
    - filter와 map은 서로 다르 연산이지만 루프 퓨전 기법을 통해 한 과정으로 병합이 가능
  - 최종 연산: 스트림을 닫는 연산 (collect)
    - 스트림 파이프 라인에서 결과를 도출
    - 최종 연산에 의해 스트림 이외의 결과를 반환
  - 스트림 이용 과정
    - 질의를 수행할 데이터 소스
    - 스트림 파이프라인을 구성하는 중간 연산 연결
    - 스트림 파이프라인을 실행하 결과를 도출할 최종 연산
    - 참고) 빌더패턴: 별도의 Builder 클래스를 만들어 build() 메소드를 통해 최종적으로 하나의 인스턴스를 리턴하는 방식
  
