3. 람다 표현식
> 람다 표현식은 익명 클래스처럼 이름이 없는 함수면서 메서드를 인수로 전달할 수 있으므로 일단은 람다표현식이 익명 클래스와 비슷하다고 생각하자

3.1 람다란 무엇인가?
> 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것
> 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다.

* 람다의 특징
1. 익명
 > 보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.
2. 함수
 > 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함한다.
3. 전달
 > 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
4. 간결성
 > 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.
 
 
람다 표현식은 파라미터, 화살표, 바디로 이루어진다.
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
   람다 파라미터     화살표              람다바디
   

3.2.2 함수 디스크립터
> 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.
  람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.
  

3.4.3 Funtion
> 자바의 모든 형식은 참조형(Byte, Integer, Object, List) 아니면 기본형(int, double, byte, char)에 해당한다.
  하지만 제네릭 파라미터(예를 들면 Consumer<T>의 T)에는 참조형만 사용할 수 있다.
> 자바에서는 기본형을 참조형으로 변환하는 기능을 제공한다. 이 기능을 박싱이라고 한다.
  참조형을 기본형으로 변환하는 반대 동작을 언박싱이라고 한다.
  프로그래머가 편리하게 코드를 구현할 수 있도록 박싱과 언박싱이 자동으로 이루어지는 오토박싱이라는 기능도 제공한다.
  
3.5.2 같은 람다, 다른 함수형 인터페이스
> Predicate는 불리언 반환값을 갖는다.
  Predicate<String> p = s -> list.add(s);
  Consumer는 void 반환값을 갖는다.
  Consumer<String> b = s -> list.add(s);
  
다음 코드를 컴파일할 수 없는 이유
Object o = () > { Systema.out.println("Trickey example"); };
> 람다 표현식의 콘텍스트는 Object(대상 형식)다. 하지만 Object는 함수형 인터페이스가 아니다.

따라서 () -> void 형식의 함수 디스크립터를 갖는 Runnable로 대상 형식을 바꿔서 문제를 해결할 수 있다.
Runnable r = () -> { Systema.out.println("Trickey example"); };

람다 표현식을 명시적으로 대상 형식을 제공하는 Runnable로 캐스팅해서 문제를 해결할 수도 있다.
Object o = (Runnable) () -> { Systema.out.println("Trickey example"); };


