### 6
# 스트림으로 데이터 수집

- 콜랙터 클래스로 컬렉션 만들고 사용
- 하나의 값으로 데이터 스트림 리듀스
- 특별한 리듀싱 요약 연산
- 데이터 그룹화와 분할
- 자시만의 커스텀 컬렉터 개발

## 예시
- 통화별로 트랜잭션을 그룹화한 다음 해당 통화로 일어난 모든 트랜잭션 합계를 계산
- 트랜잭션을 비싼 트랜잭션과 저렴한 트랜잭션 두 그룹으로 분류
- 트랜잭션을 도시 등 다수준으로 그룹화 , 각 트랜잭션이 비싼지 저렴한지 구분

``` java
//명령어 코드
Map<Currency, List<Transaction>> transactionByCurrencies = new HashMap<>();

for(Transaction tran :transaction ){
    Currency cur = transaction.getCurrency();
    List<Transaction> trans = transactionByCurrencies.get(cur)

    if(trans == null) {
        trans = new ArrayList<>();
        transactionByCurrencies.put(cur, trans);
    }

    trans.add(transaction)
}

```
- 명령형 : 복잡하고 길다.


```java
//함수형
Map<Currency, List<Transaction>> transactionByCurrencies = 
transactions.stream().collect(groupingBy(Transaction::getCurrency));
```
- 함수형 

## 6.1
# 컬렉터란 무엇인가?
- Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.
- 다수준으로 그룹화를 수행할때 명령형은 다중 루프와 조건문이 추가되며 가독성과 유지보수성이 떨어진다.

## 6.2
# 고급 리듀싱 기능을 수행하는 컬렉터
- collect로 결과를 수집하는 과정을 간단하면서도 유연한 방식으로 정의할 수 있다는점이 컬렉터의 최대 강점이다.
- 가장 많이 사용하는 직관적인 정적메서드 toList

```java
List<test> tests = testStream.collect(Collector.toList())
```

## 6.1.2 
# 미리 정의된 컬렉터
- 스트림 요소를 하나의 값으로 리듀스하고 요약
    - 리스트의 총합 및 다양한 계산 수행
- 요소 그룹화
    - 다수준으로 그룹화 각각 결과의 서브그룹에 추가로 리듀싱 연산적용
- 요소분할
    - 파티셔닝 : 한 개의 인수를 받아 불리언을 반환하는 함수

## 6.2
# 리듀싱과 요약 
- 컬렉터로 스트림의 항목을 컬렉션으로 재구성 할 수 있다.
(컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있음)

- counting() 팩토리메서드
```java
long dishs = menu.stream().collect(Collectors.counting());
// 생략시
long dishs = menu.stream().count();
```
- 카운팅 컬렉터는 다른 컬렉터와 함께 사용할 때 위력을 발휘한다.

## 6.2.1 
# 스트림 값에서 최댓값과 최솟값 검색
- Collectors.maxBy , Collectors.minBy 를 통해 계산 가능하다.
- 두 컬렉터는 스트림의 요소를 비교하는데 사용할 Comparator 를 인수로 받는다.

```java
Comparator<Dish> dishCalroriesComparator = 
Comparator.comparingInt(Dish::getCalrories);

Optional<Dish> mostCalories = menu.stream().collect(maxBy(dishCalroriesComparator));

```
- 옵셔널의 경우 menu가 비어있다면 아무것도 반환되지 않기 때문에 오류를 발생시키지 않으려고 쓴다.



## 6.2.2
# 요약 연산
- Collectors.summingInt : 객체를 int로 맵핑하는 함수를 인수로 받는다.
- summingInt 의 인수로 전달된 함수는 객체를 int로 맵핑한 컬렉터를 반환한다.

```java
int totalCal = menu.stream().collect(summingInt(Dish::getCalorie));
```
- long, double의 경우 : summingLong, summingDouble
- 평균 : avarageInt 식으로 사용된다.
- 동시에 계산시킬 경우
```java
IntSummaryStatis test = menu.stream().collect(summarizingInt(Dish::getCalories));
```
- 이 카운트, 합산, 최소, 최대 , 평균을 모두 제공

## 6.2.3 
# 문자열 연결
- 컬렉터에 joining 팩토리 메소드를 이용하면 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환한다.
```java
String shorMenu = menu.stream().map(Dish::getName).collect(joining());
```
- 그대로 쓰면 구분자가 없다
- 오버로드된 메서드 joining(", ")를 통해 구분자를 넣을 수 있다.

## 6.2.4
# 범용 리듀싱 요약 연산
-  지금까지의 모든 컬렉터는 reducing 팩토리 메서드로도 정의가 가능하다.
```java
//모든 칼로리의 합계
menu.stream().collect(reducing(0, Dish::getCalories, (i,j) -> i+j));
```
- 리듀싱은 3개의 인수를 받는다.
- 1번 : 시작값이거나 스트림에 인수가 없을 때 반환값
- 2번 : 요리를 칼로리 정수로 변환할때 사용한 변환 함수
- 3번 : 같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator

- 무엇이 다를가? : 의미론적인 문제와 실용성 문제가 있다.
    - collect메서드는 도출하려는 결과를 누적하는 컨테이너를 바꾸도록 설계되었으나 reduce는 두 값을 하나로 도출하는 불변형 연산이라는 점에서 의미론적인 문제가 발생한다.
    - reduce를 잘못 사용하면 실용성 문제도 발생하고 연산을 병렬로 수행할 수 없어진다.
    - 가변 컨테이너 관련 작업이면서 병렬성을 확보하려면 collect 메서드로 리듀싱 연산을 구현하는게 바람직하다.

    ## 6.3
    # 그룹화